# Задание 2. Теоретическое задание: параллелизуемость/code divergence/memory coalesced access

*Степан Остапенко (ИТМО)*

## 1

Я считаю, что первый сигнал вычислить проще, поскольку его элементы можно вычислять независимо друг от друга, а во втором сигнале каждый следующий элемент зависит от двух предыдущих, поэтому мы не можем начать вычислять очередной элемент второго сигнала, пока не вычислим все его предыдущие элементы. (На самом деле, вроде как, можем, но для этого потребуется схема с двоичным деревом как в задаче вычисления глобальной суммы. Но это всё равно сложнее, чем посчитать первый сигнал.)

## 2

Поскольку у WorkItem'а чаще всего меняется `x`-координата, а размер WorkGroup по оси `x` равен размеру Warp, то разделение WorkGroup по Warp'ам будет происходить построчно, т. е. на каждый Warp попадёт какая-то строка из WorkGroup.

Теперь заметим, что в указанном выражении `get_local_size(1) * get_local_id(0)` всегда кратно 32, поскольку `get_local_size(1) = 32`, а `get_local_id(1)` будет одинаковым для всех WorkItem'ов внутри одного Warp'а. Поэтому значение `idx % 32` будет одинаковым для всех потоков внутри одного Warp'а.

В таком случае, внутри одного Warp'а либо у всех потоков будет выполняться первая ветка `if`, либо у всех потоков будет выполняться вторая ветка `if`. Так что code divergence не произойдет.

## 3

### a

Да, будет, т. к. соседние WorkItem'ы (которые попадут на один Warp), будут запрашивать последовательные элементы массива `data`.

Заметим, что одна кеш-линия вмещает в себя 32 float'a, т. е. ровно тот объём данных, который будет запрошен в одной строчке из WorkGroup, поэтому на каждую строчку будет записана одна кеш-линия. Таким образом, всего будет записано 32 кеш-линии.

### b

Нет, не будет. т. к. соседние WorkItem'ы (которые попадут на один Warp), будут запрашивать элементы с разницей индексов равной 32. А поскольку каждая кеш-линия вмещает в себя 32 элемента массива `data`, видеокарте придётся записывать по одной кеш-линии на каждый WorkItem. Таким образом, всего будет записано $32 \cdot 32 = 1024$ кеш-линии, если не учитывать работу L1-кеша.

### c

Да, будет, как и в пункте a. Однако теперь последние элементы в каждой строчке будут всегда вылазить за кеш-линию, которую запрашивают остальные элементы, поэтому для них всегда придётся делать отдельную запись. Таким образом, всего будет записано 32 кеш-линии на все элементы, кроме последнего столбца, и ещё 32 кеш-линии на последние элементы в каждой строке, итого 64 кеш-линии.
