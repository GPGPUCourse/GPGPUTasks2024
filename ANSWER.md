**1)**

Легче реализовать y1, так как для вычисления такого сигнала не требуется синхронизация потоков.

**2)**

Проэмулируем условие из кернела на питоне для ворк группы:
```
>>> np.array([[((y + 32 * x) % 32) < 16 for y in range(32)] for x in range(32)])
array([[ True,  True,  True, ..., False, False, False],
       [ True,  True,  True, ..., False, False, False],
       [ True,  True,  True, ..., False, False, False],
       ...,
       [ True,  True,  True, ..., False, False, False],
       [ True,  True,  True, ..., False, False, False],
       [ True,  True,  True, ..., False, False, False]])
```

Видим, что в любом из столбцов булевы значения одинаковы.
Так как варп всегда будет исполнять какой-то столбец воркгруппы, все потоки будут проходить в одну и ту же ветвь if-а и code divergence не будет.

**3)**

(a)
Проэмулируем запись ворк группы на питоне:
```
>>> np.array([[(x + 32 * y) for y in range(32)] for x in range(32)])
array([[   0,   32,   64, ...,  928,  960,  992],
       [   1,   33,   65, ...,  929,  961,  993],
       [   2,   34,   66, ...,  930,  962,  994],
       ...,
       [  29,   61,   93, ...,  957,  989, 1021],
       [  30,   62,   94, ...,  958,  990, 1022],
       [  31,   63,   95, ...,  959,  991, 1023]])
```

Так как варп всегда исполняет какой-то столбец ворк группы (а адреса в столбце непрерывны и выравнены), запись будет одна и она будет coalesced.
Так как столбцов 32, то и записей будет 32.

(b)
Снова проэмулируем запись ворк группы на питоне:
```
>>> np.array([[(y + 32 * x) for y in range(32)] for x in range(32)])
array([[   0,    1,    2, ...,   29,   30,   31],
       [  32,   33,   34, ...,   61,   62,   63],
       [  64,   65,   66, ...,   93,   94,   95],
       ...,
       [ 928,  929,  930, ...,  957,  958,  959],
       [ 960,  961,  962, ...,  989,  990,  991],
       [ 992,  993,  994, ..., 1021, 1022, 1023]])
```

Здесь у одного варпа обращение к памяти будет не coalesced, так как адреса в каждом столбце не непрерывны.
Запись в рамках каждого варпа будет порождать 32 записи, а каждый столбец исполнится 32 раза, следовательно будет 1024 записи.

(c)
Проэмулируем запись на питоне:
```
>>> np.array([[(1 + x + 32 * y) for y in range(32)] for x in range(32)])
array([[   1,   33,   65, ...,  929,  961,  993],
       [   2,   34,   66, ...,  930,  962,  994],
       [   3,   35,   67, ...,  931,  963,  995],
       ...,
       [  30,   62,   94, ...,  958,  990, 1022],
       [  31,   63,   95, ...,  959,  991, 1023],
       [  32,   64,   96, ...,  960,  992, 1024]])
```

Здесь в столбце адреса непрерывны, но не выравнены по 128 байт, поэтому запись не coalesced.
Каждый варп, выполняя столбец ворк группы будет делать 2 записи: [1..31], [32].
Всего столбцов 32, значит будет 64 записи.
