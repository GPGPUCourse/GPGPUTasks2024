1) `y1` реализовать проще. В `y2` для подсчёта элемента n надо значить элементы `n-1` и` n-2`.
Из-за этого одновременный подсчёт `n` и `n-1` невозможен. `y1` мы можем считать для любого n независимо и одновременно, 
потому что они зависят лишь от значений x.
2) Не произойдёт.
Рабочая группа (32, 32, 1) укладывается на warp размера 32, и чаще всего меняется номер по оси x
=> в пределах одного варпа будут будут WorkItem с равными номерами по оси y и z и с различными по оси x.
Но `get_local_size(1) * get_local_id(0)` всегда кратен 32, т.к. `get_local_size(1)=32`,
поэтому номер WorkItem по оси x на отмаскированность не влияет.
А вот `get_local_id(1)` влияет на отмаскированность непосредственно - когда оно меньше 16,
исполняется `foo`, а когда больше - `bar`
Но в пределах одного warp `get_local_id(1) = const`.
Следовательно, warp будут либо целиком выполнять `foo`, либо `bar`.
3) (a) Да, обращение будет идеально coalesced, т.к. номер по оси `x` меняется чаще всего и 
обращения к `data` являются последовательными.
Каждый warp будет последовательно записывать 32*4=128 байт в 1 кэш-линию.
Т.к. всего мы уложили группу в 32 варпа, понадобится ровно столько записей кэш-линий - **32**.

   (b) Нет, обращение не будет `coalesced`.
Каждый варп будет записывать значения с шагом в 128 байт - потому что `get_local_id(0)` различны для каждого элемента внутри варпа.
То есть варп будет записывать лишь 4 байта (1 значение) из 128 в одну кэш-линию, и сделает это 32 раза.
Таким образом, нам понадобится **32 * 32 = 1024 кэш-линии**

   (c) Да, обращение будет весьма coalesced.
Из-за смещения на 1 вначале в каждом варпе мы не запишем первые 4 байта кэш-линии 1,
но зато запишем лишь 4 байта в кэш-линии 2, которая следует сразу же после кэш-линии 1.
То есть, произойдет по 2 записи кэш-линии на варп. А всего **2 * 32 = 64 кэш-линии**