## Ответ на вопрос 1:

Сигнал `y2` зависит от массива `x` и от своих предыдущих значений, в то время как сигнал `y1` зависит только от массива `x`, что делает проще вычисления сигнала `y1`, поскольку все его значения вычисляются независимо.

## Ответ на вопрос 2:

Из условия получаем, что `get_local_id(1) = const` внутри одного warp/wavefront. Поэтому 

```idx ≡ get_local_id(1) + get_local_size(1) * get_local_id(0) ≡ const + 32 * get_local_id(0) ≡ const (mod 32)```

Таким образом все потоки в варпе будут заходить в одну и ту же ветку, и code divergence не произойдет.

## Ответ на вопрос 3:

(a) При данных условиях варп будет обращаться к 32-м последовательным элементам, поэтому и доступ будет coalesced. А записей будет `32 * 128 / 32 / sizeof(float) = 32`.

(b) Внутри одного варпа все потоки будут обращаться к разным кеш линиям, а поэтому записей нужно будет сделать `32 * 32 = 1024`

(c) Индексы, как и в (а), идут последовательно, однако есть смещение на 1, и поэтому на каждый запрос требуется 2 кеш линии, поэтому всего записей `64`.