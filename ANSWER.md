# Задание 2. Теоретическое задание: параллелизуемость/code divergence/memory coalesced access

**Дедлайн**: 23:59 29 сентября.

**1)** Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

Ответ: Проще и быстрее реализовать в модели массового параллелизма на GPU будет первый сигнал. В первом случае мы можем обработку каждого сигнала поручить отдельному потоку, т. к. нам не нужно использовать результаты работы других потоков, нам не нужно задумываться о какой-либо синхронизации между ними. Второй сигнал нужно будет реализовать строго в порядке возрастания n. Здесь необходимо синхронизировать работу различных потоков.

**2)** Предположим что размер warp/wavefront равен 32 и рабочая группа делится
 на warp/wavefront-ы таким образом что внутри warp/wavefront
 номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence.

Пусть размер рабочей группы (32, 32, 1)

```
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

Произойдет ли code divergence? Почему?

Ответ: В данном случае code divergence не произойдёт. Исходя из способа подачи WorkItem на warp/wavefront-ы в первую очередь придут все WorkItem с одной и той же y-координатой, т. к. размер варпа - 32, то после выполнения больше WorkItem с этой координатой не останется и warp/wavefront переключится на выполнение следующей группы WorkItem, которые также все имеют одну y-координату, и никакие другие WorkItem не имеют такую же. `get_local_size(1)` выдаст нам размерность по y-координате - 32. Т. е. `idx % 32` определяется только `get_local_id(1)`, которая выдаст нам y-координату. А т. к. на одном warp/wavefront в один момент времени исполняются WorkItem с одной и той же y-координатой, то результат `idx % 32` для всего warp/wavefront будет один. Значит warp/wavefront исполнит либо полностью одну ветку, либо полностью другую.

**3)** Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится
 на warp/wavefront-ы таким образом что внутри warp/wavefront
 номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

Ответ: обращение будет coalesced. В данном случае на warp/wavefron опять же пойдут WorkItem с одной и той же y-координатой. В данном случае на запись для всего warp/wavefront будет достаточно одной кэш-линии за раз (обращаемся к ячейкам памяти строго подряд по 4 байта, 32 (размер warp/wavefron) * 4 = 128 байт). Всего потребуется задействовать 32 warp/wavefront (параллельно или, возможно, некоторые будут задействованы последовательно) исходя из размера рабочей группы, т. е. всего 32 кеш линий записей.

(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

Ответ: обращение не будет coalesced. В данном случае на warp/wavefron опять же пойдут WorkItem с одной и той же y-координатой. Но в данном случае мы будем обращаться не к соседним ячейкам, а через `get_local_size(1) = 32` ячейки по 4 байта, что в любом случае не влезет в кэш-линию. В одном warp/wavefront произойдёт ровно 32 кеш линий записей. Всего потребуется задействовать 32 warp/wavefront (параллельно или, возможно, некоторые будут задействованы последовательно) исходя из размера рабочей группы, т. е. всего 1024 кеш линий записей.

(c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

Ответ: обращение не будет полностью coalesced. В данном случае на warp/wavefron опять же пойдут WorkItem с одной и той же y-координатой. В данном случае на запись для всего warp/wavefront будет достаточно двух кэш-линий за раз (обращаемся к ячейкам памяти строго подряд по 4 байта, 32 (размер warp/wavefron) * 4 = 128 байт, 4 байта - вылезаем на следующую кэш-линию). Всего потребуется задействовать 32 warp/wavefront (параллельно или, возможно, некоторые будут задействованы последовательно) исходя из размера рабочей группы, т. е. всего 64 кеш линий записей.
