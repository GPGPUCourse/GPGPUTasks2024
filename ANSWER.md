# Вопрос 1

Ответ: первый вариант

Причина:
Т.к. для вычисления `y1[n] = x[n - 1] + x[n] + x[n + 1]` не требуется зависимость от других `y1`,
а для вычисления `y2[n] = y2[n - 2] + y2[n - 1] + x[n]` требуется предварительное вычисление `y2[n - 2]` и `y2[n - 1]`,
поэтому первое можно вычислять в отдельном потоке без синхронизации, а второе - нет

# Вопрос 2

Размеры известны, поэтому можем упростить неравенство: `idx % 32 < 16`:

```c++
(get_local_id(1) + get_local_size(1) * get_local_id(0)) % 32
= (get_local_id(1) + 32 * get_local_id(0)) % 32
= get_local_id(1) % 32
= get_local_id(1)
```

Т.к. размер warp - 32 и изменение индекса идет в порядке 0 -> 1 -> 2,
то внутри варпа меняется только `get_local_id(0)`, когда `get_local_id(1) = const`

А значит условие в warp константное, а значит code divergence нет.

# Вопрос 3

Для простоты посмотрим на индексы warp, начинающийся с `get_local_id(0) = 0` и `get_local_id(1) = 0`:

## Пункт a)

Обращение к памяти происходит по индексам:
* `0 + 32 * get_local_id(1)`
* `1 + 32 * get_local_id(1)`
* ...
* `31 + 32 * get_local_id(1)`

то есть последовательные выровненные 128 байт, как раз по размеру кеша.
Значит обращение к памяти coalesced и в группе будет 32 кеш записей

## Пункт b)

Обращение к памяти происходит по индексам:
* `0 + get_local_id(1)`
* `32 + get_local_id(1)`
* ...
* `992 + get_local_id(1)`

То есть каждое обращение к памяти на новой кеш линии и производит новую кеш запись.
Значит обращение к памяти не coalesced и в группе будет 1024 кеш записей.

## Пункт c)

Обращение к памяти происходит по индексам:
* `1 + 32 * get_local_id(1)`
* `2 + 32 * get_local_id(1)`
* ...
* `32 + 32 * get_local_id(1)`

То есть последовательные, но не выровненные 128 байт, поэтому и задеваются два кеш линии.
Значит обращение к памяти не coalesced и в группе будет 64 кеш записи.
