# Ответ на задание 2
## 1. Сигнал y1[n] будет проще и быстрее реализовать.
Значение сигнала y1[n] зависит только от значения сигнала x[n] и от соседних с ним сигналов (обращение к памяти coalesced). Значение сигнала y2[n] зависит от значения сигнала x[n] и от двух предыдущих значений y2, вызывается рекурсивно, т.е. не параллелится.

## 2. Code divergence не произойдет.
idx имеет формулу:
```
idx = y_id + 32 * x_id
```
Для y = 0
idx = [0, 32, 64, 92, ...], при x = [0, 1, 2, 3, ...] - idx % 32 == 0

Для y = 1
idx = [1, 33, 65, 93, ...] - idx % 32 == 1

Для y = [0, ... 15], condition == true, для остальных - false.

Поскольку исполняемая инструкция выбирается на основе y, а в 1 warp помещается весь проход по x, то сode divergence не произойдет.

## 3a. Да, 32.
idx имеет формулу:
```
idx = x_id + 32 * y_id
```
Для y = 0. idx = [0, 1, 2, 3, ..., 31], при x = [0, 1, ..., 31]
Для y = 1. idx = [32, 33, ..., 63], при x = [0, 1, ..., 31]
Т.о. обращение к памяти coalesced.

Посчитаем сколько данных типа float поместиться в кэш: 128 / 4 = 32, т.е. все значения для одного y.
idx для y = 0 поместиться в кэш, idx для y = 1 тоже и т.д.
Количество записей кэш линий равно 1 * количество warp, т.е. 32 

## 3b. Нет, 1024.
idx имеет формулу:
```
idx = y_id + 32 * x_id
```
Для y = 0. idx = [0, 32, 64, ..., 992], при x = [0, 1, ..., 31]
Для y = 1. idx = [1, 33, 65, ..., 993], при x = [0, 1, ..., 31]
Т.о. обращение к памяти не coalesced.

После чтения x = 0, y = 0, z = 0 в кэше нет следующего элемента, поэтому нам приходится снова читать из VRAM в кэш.
Поэтому количество записей кэш линий равно 32 * количество warp, т.е. 32 * 32 = 1024

## 3c. Да, 32.
idx имеет формулу:
```
idx = 1 + x_id + 32 * y_id
```
Для y = 0. idx = [1, 2, 3, 4, ..., 32], при x = [0, 1, ..., 31]
Для y = 1. idx = [33, 34, ..., 64], при x = [0, 1, ..., 31]
Т.о. обращение к памяти coalesced.
idx для y = 0 поместиться в кэш, idx для y = 1 тоже и т.д.
Количество записей кэш линий равно 1 * количество warp, т.е. 32 