### Задание 2. Теоретическое задание: параллелизуемость/code divergence/memory coalesced access

1Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

y1[n] = x[n - 1] + x[n] + x[n + 1]
y2[n] = y2[n - 2] + y2[n - 1] + x[n]
Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

```
В модели массового параллелизма на GPU быстрее будет реализовать первый, так как в этом случае i-ый сигнал не зависит от предыдущих значений сигнала (во втором случае существует рекурсивная зависимость), а, значит, может быть параллелизован более легко. 
```

2) Предположим что размер warp/wavefront равен 32 и рабочая группа делится на warp/wavefront-ы таким образом что внутри warp/wavefront номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence.

Пусть размер рабочей группы (32, 32, 1)

int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
foo();
else
bar();
Произойдет ли code divergence? Почему?

```
По условию имеем 32 варпа по 32 потока в каждом. 
Да, в данном случае произойдет code divergence, так как в коде внутри одного warp первую ветку кода будет исполнять одна половина потоков (16 элементов), а вторую ветку - вторая половина. Из-за того, что варпы исполняют синхронно одну инструкцию для всех потоков, происходит ветвление и, как следствие, снижается производительность.
```

3) Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится на warp/wavefront-ы таким образом что внутри warp/wavefront номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1). Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

(a)

data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

```
Чаще всего меняется координата x, поэтому данные для всех потоков варпа будут расположены последовательно в памяти.
Доступ к памяти будет coalesced, так как доступ к памяти выровненный по 128 байт (а мы имеем как раз 32 потока по 4 байт = 128). Количество кеш-линий будет 1, так как все 32 потока будут записывать каждый по 4 байта, что равно 128 байтам (кеш линия)
```

(b)

data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

```
В данном случае индексы меняются быстрее по y. Это означает, что потоки одного варпа будут обращаться к непоследовательным участкам памяти. В этом случае доступ к памяти будет на расстоянии размера рабочей группы x, поэтому доступ к памяти не будет coalesced.
Кол-во кеш-линий равно 32, так как доступ не последовательный - каждый поток будет использовать свою линию.
```

(c)

data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

```
Этот пункт похож на п.(а), за исключением того, что индексы сдвинуты на 1. Но доступ будет все равно последовательный, хоть и сдвинут.
Таким образом, сохраняется coalesced доступ к памяти, а кол-во кеш-линий = 1.
```