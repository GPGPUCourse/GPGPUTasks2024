1)
    1) В первом варианте у нас переменная `y` зависит только от значений `x`, что не требует синхронизации работы потоков 
    2) Во втором варианте у нас `y` так же зависит от своих других значений, поэтому для корректной работы мы должны гарантировать их более ранее исполнение

    Отсюда можно сделать вывод, что первый вариант будет работать быстрее.
 
2) Как мы знаем по описанию задачи, то внутри одной одного warp `get_local_id(1)` будет 
иметь константное значение, а `get_local_size(1) = 32`, поэтому `idx` 
внутри warp будет иметь константное значение и мы не получим code divergence.  
3)
    1) Внутри одного warp у нас индексы будут пробегать значения `k + 32 * get_local_id(1) : k \in [0..31]`
        поэтому мы имеем хорошее обращение к памяти в плане coalesced. 

       На каждый warp у нас потребуется по 1 обращении к памяти и записи в кеш линию, отсюда мы получаем 32
        кеш линии. 
    
    2) В данном варианте обращение внутри одного warp будет происходить к 
       данным ячейкам `get_local_id(1) + get_local_size(1) * get_local_id(0) = const + 32 * k : k \in [0..31]`
        Получается, что одно обращение к памяти будет давать 1 попадание в рамках одного warp, а нам надо 32.
        
        Итого выходит `32 * 32 = 1024`.
   3) По аналогии со случаем `3.1`, но с отличием в том, что теперь мы не попадаем в одну кеш линию и потребуется 2
      по причине, что у нас `data % 128 == 0`, то есть имеется выравнивание float.
   
      Поэтому теперь мы получим `32 * 2 = 64`.