# Задание 2. Теоретическое задание: параллелизуемость/code divergence/memory coalesced access
## 1. Два сигнала
### Условие

_Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:_

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

_Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?_

### Решение
Вычисление `y1` проще реализовать на GPU, потому что `y1`, в отличие от `y2`, не содержит зависимостей по данным от чего-то, отличного от входного сигнала, то есть такую функцию легко параллелизовать самым простым алгоритмом (хоть на OpenMP): все доступы в память будут coalesced. 

Возможно, `y2` тоже можно считать быстро, без зависимостей по данным от `y2`: возможно, если решить рекурренту, то нужно будет лишь домножать элементы сигнала `x` на какой-то предварительно посчитанный коэффициент `f`, но это точно не проще (больше кода) и не быстрее (больше инструкций байткода), чем вычисление `y1`.

## 2. Code divergence
### Условие
_Предположим что размер warp/wavefront равен 32 и рабочая группа делится_
 _на warp/wavefront-ы таким образом что внутри warp/wavefront_
 _номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z._

_Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence._

_Пусть размер рабочей группы (32, 32, 1)_

```
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

_Произойдет ли code divergence? Почему?_

### Решение
`get_local_id(1)` возвращает одинаковое число `y` для всех потоков внутри одного warp/wavefront, потому что внутри одного warp/wavefront индекс по второму измерению будет фиксирован (т. к. размер warp/wavefront совпадает с размером рабочей группы). `get_local_size(1)` равен `32`, поэтому выражение `idx % 32 < 16` упрощается до `y < 16`: а поскольку `y` одинаковый внутри warp/wavefront, то **code-divergence не произойдёт**.

## 3. Обращения к памяти
### Условие
_Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится_
 _на warp/wavefront-ы таким образом что внутри warp/wavefront_
 _номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z._

_Пусть размер рабочей группы (32, 32, 1)._
_Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт._

(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

_Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?_

(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```

_Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?_

(c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

_Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?_

### Решение
(a) `get_local_size(1)` - константа, равная `32`. `get_local_id(1)` у всех потоков внутри одного warp одинаковый. Поэтому получаем обращение к 32-м последовательным элементам, доступ будет coalesced, записей кэшлиний будет `128 / (32 * sizeof(float)) * 32 = 32`.

(b) `get_local_id(1)` одинаковое значение для всех потоков внутри одного warp, а `get_local_size(1)` - константа равная `32`. Таким образом, мы двигаемся с шагом `get_local_size(1)`, увеличивая `get_local_id(0)` внутри одного warp. Таким образом, каждый warp использует 32 кэшлинии, но использует лишь 4 байта из 128-ми, т. е. доступ не coalesced. В рабочей группе будет использовано `32 * 32 = 1024` кэшлинии.

(с) Случай аналогичен (a), но теперь доступ происходит unaligned. То есть теперь запись будет занимать 2 кэшлинии на варп, записывая в память размером в одну кэшлинию. Доступ получился не coalesced. Всего work-group запишет в 33 кэшлинии.
