# Задание 1.
`y1` посчитать проще, так как каждое его значение зависит только от входного массива `x`, но не друг от друга, благодаря чему весь `y1` можно вычислять независимо друг от друга. 

В случае же `y2`, для каждого значения `y2[i]` нам как минимум нужно значение `y2[i - 1]`, из-за чего все вычисления `y2` должны быть в порядке от меньшего индекса к большему (не получится выполнять независимо, т.е. распараллелить).


# Задание 2.
Номер workitem меняется чаще всего по оси X, а значит в одном варпе `get_local_id(1)` будет константой. Тогда `get_local_id(1) + get_local_id(0) * get_local_size(1) = const + get_local_id(0) * 32`, то есть `idx % 32 = const`, и code divergence не случится.

# Задание 3.

## a)
Да, будет. Первый варп пишет в индексы 0, 1, ..., 31, второй варп в 32, 33, ..., 63, и так далее. Каждый варп пишет в последовательный блок памяти размера 32 * sizeof(float) = 128 байт, что как раз соответствует одной кэш-линии. Так как варпов 32, то будет и 32 записи кэш-линий.

## b)
Нет, так как теперь, например, первый варп пишет в индексы 0, 32, 64, ..., то есть между соседними элементами уже 128 байт, из-за чего никакие два не поместятся в одну кэш-линию, и придется делать 32 запроса к глобальной памяти. Аналогично, будет 1024 записей кэш-линий.

## c)
Не совсем. Так как массив `data` в глобальной памяти выровнен по 128 байт, а в этом случае у нас каждый варп запрашивает индексы 1, 2, ..., 32, то на это нужно 2 записи кэш-линий (индексы 1-31 в одной, 32 в другой). Тогда всего запросов 64 (не так плохо, но не 32).