**1)**

Сигнал y1 будет вычислить проще и быстрее, потому что каждый из его элементов вычисляется независимо (для вычисления потребуется только чтение из сигнала x). 

В случае y2, вычисление каждого элемента будет зависеть от результата вычисления предыдщих элементов. Такая зависимость создаёт последовательную природу вычислений, которая плохо подходит для массового параллелизма.

**2)**

По условию соседние потоки в warp будут по возможности соседями в одной строчке, а размер WorkGroup по оси X равен размеру warp, следовательно каждый WorkItem в warp будет иметь одну и ту же координату по оси y.

Так как остаток от деления для каждого WorkItem в warp/wavefront (определяется get_local_id(1)) будет одинаковым, все потоки будут выполнять одну и ту же инструкцию, а следовательно code divergence не будет происходить.

**3)**

(a) Да, будет. Поскольку data является идеально выровненым, то WorkItem в warp будут запрашивать последовательность элементов, причем для каждого warp будет записана всего одна кэш линия. Всего будет 32 линии.

(b) Нет, поскольку WorkItem в warp будут читать элементы из массива data с разностью в 32 элемента. Каждый поток будет записывать кэш линию из памяти для себя. Таким образом будет 1024 записей.

(c) Будет частично coalesced. В отличие от пункта а, последний элемент линии не будет размещен в запрашиваемой линии. Для него будет запрашивать отдельная кэш линия длиной в 128 байт. Таким образом, произойдет в два раза больше записей в кэш - 64 линии. 