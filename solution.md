### 1 Задание
    y1[n] = x[n - 1] + x[n] + x[n + 1]
    y2[n] = y2[n - 2] + y2[n - 1] + x[n]

Первый вариант реализовать проще, поскольку используются данные из другого массива и нет необходимости дожидаться пока будет посчитан предыдущий элемент. Также используется только одно обращение к глобальной памяти, так как данные лежат последовательно. Во втором варианте происходит чтение из двух массивов.

### 2 Задание
Из-за того что размер warp/wavefront совпадает с размером workgroup по оси x, в одном warp/wavefront будут лежать workitem с x от 1 до 32 и одинаковыми y и z.Перепишем 
    
    int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
    int idx = y + 32 * x;
То есть результат idx % 32 в одном warp будет одинаковый и code divergence не произойдет.

### 3 Задание
(a)

    data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
    data[x + 32 * y] = 1.0f;

Да, будет coalesced, потому что каждый следующий поток будет обращаться к данным по id на 1 больше предыдущего. Поэтому 1 кеш линия записи на 1 warp и 32 всего.

(b)

    data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
    data[y + 32 * x] = 1.0f;

Нет, не будет, потому что каждый следующий запрос будет не попадать в кэш. Произойдет 32*32=1024 записи.

(с)

    data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
    data[1 + x + 32 * y] = 1.0f;

Не совсем coalesced. В каждом warp последний поток будет не попадать в кэш и потребуется дополнительная кэш линия. Всего 32*2=64 записи.
